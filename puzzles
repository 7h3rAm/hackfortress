1. Spy:

	Basic xor decryption of a string with a (normally unreachable) method
for obtaining the key included in the provided binary. User supplies MD5 of 
plaintext for the win. This one might be challenging.

	Key can be determined through static analysis (specifically, by 
looking at the getKey() function). However obtained, the key is then provided as a command
line argument to get the plaintext.

	Key: 2935
	Hints:
		1) Little hint: The key is in something similar to pi
		2) Big hint: Build a bridge to an island of unreachable code

	Plaintext result with correct key: 
		(metaphorical) ladykiller, (real) mankiller.

	MD5 of correct result: 
		61b7d4e5fc2ec41612dba5fae356e268

2. Sniper:

	Patch an executable or alter its execution in a debugger correctly on 
your first try for the win here. This one isn't intended to be too hard.

	It isn't too difficult to pull the plaintext out if the (simple) ciphering algorithm is reversed, but it is much easier to run this through a debugger
and make the executable call saveMe() instead of deleteMe(). However, if the 
user doesn't get it right on the first try, the file deletes itself -
forfeiting any advantage that could be gained by solving this puzzle 
(unless they made a backup first).

  Hints:
    1) Little hint: The ciphering algorithm isn't *that* hard
    2) Big hint: If you can't reverse the cipher, redirect execution to it

	Plaintext result:
		Thanks for standing still, wanker!

	MD5 of correct result:
		142baa46b11cc0a785066dcdc1158b82	
	
3. Pyro

  The binary provided here actually contains two binaries. The first one
is an unpacker which decrypts the second binary, which is then temporarily
written to disk and run with execl(). The unpacked binary takes over the 
original process image and takes control, deletes the temporary on-disk
copy of the unpacked binary, and won't spit out the victory string
unless sent the appropriate signal.

  Plaintext result:
    Mmrroommm! Mmmmmrrrrrr! *fwooosh!*

  MD5 of correct result:
    6fadffd2d794a52d230cd245796693a1

  Hints:
    1) Little hint: That is a pretty big binary.
    2) Big hint: Did I see a file drop?

4. Scout

  This one is short, but tricky. The _start entry (responsible for calling
main() ) has been modified post-compilation to push the address of a function
other than main() to be the executable's entrypoint. However, IDA Pro still
labels the fake main() as the analysis start point, and the code that actually
runs isn't listed under IDA's function entrypoints. Only those that break on
_start or analyze the address being pushed for main() will catch this one :)

In addition, I intentionally break the function entrypoint for the real main,
which confuses disassemblers. Users will have to manually mark the section
as code, which then obscures the data values contained within it.

  Plaintext result:
    *Bonk!*

  MD5 of correct result:
    f590f8752a6763294861a2a3cfee9d6a

  Hints:
    1) Little hint: Your disassembler might be hindering your progress.
    2) Big hint: This is not the main you are looking for ;)

5. Engineer
  
  This is another puzzle that is meant to frustrate people relying on 
debuggers and disassemblers to do the work for them. There are two techniques
used to alter execution in ways that require comprehension of the instructions
in order to solve this puzzle. The first overwrites a libc standard function
at runtime by overwriting exit()'s entry in the Global Offset Table with
my own function. Static analysis will show exit() or _exit() being called,
but the runtime behavior is different. If this is caught by the reverser
and they attempt to use a debugger to follow the behavior, an anti-debugging
technique is used to keep the original exit() call in place.

  The stealth exit() has had its disassembly obfuscated as well,
and the final string will only be decrypted if the user supplies the correct
argument - in this case, the integer 110.

  Plaintext result:
    I'm an engineer. Which means I solve problems.

  MD5 of correct result:
    4f9bcd9bf846343f3b676a792cce8f

  Hints:
    1) Little hint:
    2) Big hint: 
    
